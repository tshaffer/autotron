// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../react
//   ../@brightsign/bsdatamodel
//   ../redux

import * as React from 'react';
import { DmDerivedContentItem, DmEvent, DmMediaState, DmState, DmZone } from '@brightsign/bsdatamodel';
import { DmcZone } from '@brightsign/bsdatamodel';
import { Store } from 'redux';
import { Action } from 'redux';
import { Dispatch, ActionCreator } from 'redux';
import { Reducer } from 'redux';
import { ActiveHStatesShape } from './src/type/activeHState';

/** @module Controller:index */

/** @module Model:index */

/** @module Selector:index */

/** @module Types:index */

/** @internal */
export interface ImageProps {
    src: string;
    width: number;
    height: number;
}
export class ImageComponent extends React.Component<ImageProps> {
    render(): JSX.Element;
}
export const Image: React.ComponentClass<any> & {
    WrappedComponent: React.ComponentType<ImageProps>;
};

export interface VideoProps {
    width: number;
    height: number;
    onVideoEnd: () => void;
    src: string;
}
export class VideoComponent extends React.Component<VideoProps> {
    onVideoEnd(): void;
    render(): JSX.Element;
}
export const Video: React.ComponentClass<any> & {
    WrappedComponent: React.ComponentType<VideoProps>;
};

/** @internal */
export interface MediaZoneProps {
    key: string;
    bsdm: DmState;
    zone: DmZone;
    width: number;
    height: number;
    activeMediaStateId: string;
    postBSPMessage: any;
}
export default class MediaZoneComponent extends React.Component<MediaZoneProps> {
    postMediaEndEvent(): void;
    renderMediaItem(mediaState: DmMediaState, contentItem: DmDerivedContentItem): JSX.Element | null;
    getEvents(bsdm: DmState, mediaStateId: string): DmEvent[];
    render(): JSX.Element | null;
}
export const MediaZone: React.ComponentClass<any> & {
    WrappedComponent: React.ComponentType<MediaZoneProps>;
};

/** @internal */
export interface SignProps {
    bsdm: DmState;
}
export class SignComponent extends React.Component<SignProps> {
    getMediaZoneJSX(zone: DmcZone): object;
    getZoneJSX(zoneId: string): object | null;
    render(): JSX.Element;
}
export const Sign: React.ComponentClass<Pick<SignProps, "bsdm"> & undefined> & {
    WrappedComponent: React.ComponentType<SignProps>;
};

export let myApp: {};
export const App: React.ComponentClass<Pick<{
    bsdm: any;
    activeMediaStates: any;
} & null, never>> & {
    WrappedComponent: React.ComponentType<{
        bsdm: any;
        activeMediaStates: any;
    } & null>;
};

export const initModel: () => BsAutotronModelThunkAction<Promise<any>>;
export const resetModel: () => BsAutotronModelThunkAction<BsAutotronModelAction<null>>;

export function initRuntime(store: Store<BsAutotronState>): (dispatch: any, getState: Function) => Promise<void>;
export function getRuntimeFiles(): Promise<void>;
export function getPoolFilePath(fileName: string): string;
export function postRuntimeMessage(event: ArEventType): void;
export function postMessage(event: ArEventType): void;

export const SET_ACTIVE_MEDIA_STATE = "SET_ACTIVE_MEDIA_STATE";
export function setActiveMediaState(zoneId: string, mediaStateId: string): {
    type: string;
    payload: {
        zoneId: string;
        mediaStateId: string;
    };
};
export const activeMediaStateReducer: (state: ActiveMediaStatesShape | undefined, action: ActionWithPayload) => ActiveMediaStatesShape;

/** @module Model:base */
/** @private */
export interface ActionWithPayload extends Action {
    payload: any;
}
/** @private */
export const BSAUTOTRONMODEL_BATCH = "BSAUTOTRONMODEL_BATCH";
/** @private */
export const BSAUTOTRONMODEL_REHYDRATE = "BSAUTOTRONMODEL_REHYDRATE";
/** @private */
export const BSAUTOTRONMODEL_RESET = "BSAUTOTRONMODEL_RESET";
/** @private */
export type BsAutotronModelDispatch = Dispatch<BsAutotronModelState>;
/** @private */
export interface BsAutotronModelBaseAction extends Action {
    type: string;
    payload: {};
    error?: boolean;
    meta?: {};
}
/** @private */
export interface BsAutotronModelAction<T> extends BsAutotronModelBaseAction {
    payload: T;
}
/** @private */
export type BsAutotronModelActionCreator<T> = ActionCreator<BsAutotronModelAction<T>>;
/** @private */
export type BsAutotronModelThunkAction<T> = (dispatch: BsAutotronModelDispatch, getState: () => BsAutotronModelState, extraArgument: undefined) => T;
/** @private */
export const bsAutotronModelBatchAction: (action: BsAutotronModelBaseAction[]) => BsAutotronModelBatchAction;
/** @private */
export interface BsAutotronModelBatchAction extends Action {
    type: string;
    payload: BsAutotronModelBaseAction[];
}
/** @private */
export interface RehydrateBsAutotronModelParams {
    newBsAutotronModelState: BsAutotronModelState;
}
/** @private */
export type RehydrateBsAutotronModelAction = BsAutotronModelAction<RehydrateBsAutotronModelParams>;
export const bsAutotronModelRehydrateModel: (bsAutotronModelState: BsAutotronModelState) => BsAutotronModelAction<RehydrateBsAutotronModelParams>;
/** @private */
export type ResetBsAutotronModelAction = BsAutotronModelAction<null>;
export const bsAutotronModelResetModel: () => BsAutotronModelAction<null>;

/** @module Model:base */
export type BsAutotronReducer = Reducer<BsAutotronModelState>;
export const bsAutotronModelReducer: BsAutotronReducer;
export const isValidBsAutotronModelState: (state: any) => boolean;
export const isValidBsAutotronModelStateShallow: (state: any) => boolean;

export const SET_PLAYBACK_STATE = "SET_PLAYBACK_STATE";
export const stateMachineReducer: (state: StateMachineShape | undefined, action: ActionWithPayload) => StateMachineShape;

/** @module Selector:base */
/** @private */
export const bsAutotronModelFilterBaseState: (state: any) => BsAutotronModelState;
/** @private */
export const bsAutotronModelGetBaseState: (state: BsAutotronModelState) => BsAutotronModelState;

/** @module Types:base */
/** @private */
export type DeepPartial<T> = {
    [P in keyof T]?: DeepPartial<T[P]>;
};
export interface BsAutotronModelState {
    activeMediaStates: ActiveMediaStatesShape;
    activeHStates: ActiveHStatesShape;
    hsms: any[];
}
export interface BsAutotronState {
    bsdm: DmState;
    bsAutotron: BsAutotronModelState;
}

export type ARMediaStateLUT = {
    [zoneId: string]: string;
};
export type ActiveMediaStatesShape = {
    activeMediaStateIdByZone: ARMediaStateLUT;
};

export enum BsUiErrorType {
    unknownError = 0,
    unexpectedError = 1,
    invalidParameters = 2,
    invalidOperation = 3,
    apiError = 4,
    invalidModel = 5,
}
export class BsUiError extends Error {
    name: string;
    type: BsUiErrorType;
    constructor(type: BsUiErrorType, reason?: string);
}
export function isBsUiError(error: Error): error is BsUiError;

export enum BsAutotronErrorType {
    unknownError = 0,
    unexpectedError = 1,
    invalidParameters = 2,
    invalidOperation = 3,
    apiError = 4,
    invalidModel = 5,
}
export class BsAutotronError extends Error {
    name: string;
    type: BsAutotronErrorType;
    constructor(type: BsAutotronErrorType, reason?: string);
}
export function isBsAutotronError(error: Error): error is BsAutotronError;

export interface ArEventType {
    EventType: string;
    data?: any;
    EventData?: any;
}
export interface HSMStateData {
    nextState: HState | null;
}
export interface ArSyncSpecHash {
    method: string;
    hex: string;
}
export interface ArSyncSpecDownload {
    name: string;
    hash: ArSyncSpecHash;
    size: number;
    link: string;
}
export interface ArSyncSpecFiles {
    download: ArSyncSpecDownload[];
    ignore: any;
    delete: any;
}
export interface ArSyncSpec {
    meta: any;
    files: any;
}
export type ArFileLUT = {
    [fileName: string]: string;
};
export type LUT = {
    [key: string]: any;
};
export type SubscribedEvents = {
    [eventKey: string]: HState;
};
export type StateMachineShape = {};
export interface ArState {
    bsdm: DmState;
    stateMachine: StateMachineShape;
    activeMediaStates: ActiveMediaStatesShape;
}

export class HSM {
    dispatchEvent: ((event: ArEventType) => void);
    topState: HState | null;
    activeState: HState | null;
    constructorHandler: (() => void) | null;
    initialPseudoStateHandler: ((args: any) => (HState | null)) | null;
    constructor(dispatchEvent: ((event: ArEventType) => void));
    constructorFunction(): void;
    initialize(): void;
    Dispatch(event: ArEventType): void;
}
export class HState {
    topState: null;
    HStateEventHandler: (event: ArEventType, stateData: HSMStateData) => string;
    stateMachine: HSM;
    superState: HState;
    id: string;
    constructor(stateMachine: HSM, id: string);
}
export function STTopEventHandler(_: ArEventType, stateData: HSMStateData): string;

